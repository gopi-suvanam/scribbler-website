{
  "metadata": {
    "name": "Maze Solver and Generator<br><br>",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<h1>FUN WITH MAZE!!</h1>\n <h4> BY TEAM:Epic Bytes</h4>",
      "status": "",
      "output": "<h1>FUN WITH MAZE!!</h1>\n <h4> BY TEAM:Epic Bytes</h4>",
      "type": "html"
    },
    {
      "code": "<h3>Maze generation and Solving Visualiser</h3>\n<p>Our project is a maze generator and solver, both of which are implemented using Depth first Search with Backtracking.</p>\n<p>For the visuals and graphics on the screen, we used an external library called p5.js, which is a library which creates and manipulates the HTML canvas for you. We used it because it was just more convenient and easier to use than the vanilla HTML canvas.</p>",
      "status": "",
      "output": "<h3>Maze generation and Solving Visualiser</h3>\n<p>Our project is a maze generator and solver, both of which are implemented using Depth first Search with Backtracking.</p>\n<p>For the visuals and graphics on the screen, we used an external library called p5.js, which is a library which creates and manipulates the HTML canvas for you. We used it because it was just more convenient and easier to use than the vanilla HTML canvas.</p>",
      "type": "html"
    },
    {
      "code": "<div class=\"display\">\n  \t<h3>Depth First Search with Backtracking</h3>\n\t<p>The algorithm although fine for smaller mazes, is not very efficient and also when finding a solution for a maze, it doesnt always give the shortest path between two places in the maze<p>\n  \t<p>It runs at time complexity of O(V+E), where V=vertices in maze and E=Edges in maze. So assuming the maze to be a square grid of size n.</p>\n  \t<h4>Then Vertices = (n×n) = n² and Edges = (n×n-1) = (n²-1) </h4>\n\t<h4>Hence Time Complexity = O(n²) </h4>\n\t<p> Which is not a very efficient algorithm for a large sample size, like for a large maze.</p>\n\t<img src=\"https://i.ibb.co/SsBms5b/n-2-big-o.png\" alt=\"n-2-big-o\" border=\"0\">\n</div>\n",
      "status": "",
      "output": "<div class=\"display\">\n  \t<h3>Depth First Search with Backtracking</h3>\n\t<p>The algorithm although fine for smaller mazes, is not very efficient and also when finding a solution for a maze, it doesnt always give the shortest path between two places in the maze</p><p>\n  \t</p><p>It runs at time complexity of O(V+E), where V=vertices in maze and E=Edges in maze. So assuming the maze to be a square grid of size n.</p>\n  \t<h4>Then Vertices = (n×n) = n² and Edges = (n×n-1) = (n²-1) </h4>\n\t<h4>Hence Time Complexity = O(n²) </h4>\n\t<p> Which is not a very efficient algorithm for a large sample size, like for a large maze.</p>\n\t<img src=\"https://i.ibb.co/SsBms5b/n-2-big-o.png\" alt=\"n-2-big-o\" border=\"0\">\n</div>\n",
      "type": "html"
    },
    {
      "code": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/addons/p5.sound.min.js\"></script>\n    <meta charset=\"utf-8\" />\n  </head>\n  <body>\n    <main>\n      <style>\n\t\thtml {\n\t\t  background-color: rgb(50, 50, 50);\n\t\t}\n\n\t\timg {\n\t\t\ttext-align: center;\n\t\t}\n\t\t\n\t\th1 {\n\t\t\tfont-weight: bold;\n\t\t}\t\t\n\n\t\th4 {\n\t\t\tcolor: rgb(0, 255, 0);\n\t\t}\n\n\t\thtml, body {\n\t\t  margin: 10px;\n\t\t  padding: 0;\n\t\t}\n\n\t\tcanvas {\n\t\t  display: flex;\n\t\t}\n\n\t\tmain {\n\t\t  display: flex;\n\t\t  justify-content: center\n\t\t}\n\t\tbody {\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t}\n\n\t\tbutton {\n\t\t\tmargin: 10px auto 0px auto;\n\t\t\tpadding: 10px;\n\t\t\tmax-height: 50px;\n\t\t  max-width: 200px;\n\t\t\tborder: 5px solid rgb(50, 50, 50);\n\t\t\tfont-size: large;\n\t\t\tfont-weight: bold;\n\t\t\tborder-radius: 15px;\n\t\t\tcursor: pointer;\n\t\t\tbackground-color: rgb(220, 220, 220);\n\t\t}\n\n\t\tbutton:hover {\n\t\t\ttransform: scale(1.1);\n\t\t\tbackground-color: rgba(100, 255, 100, 50)\n\t\t}\n\n\t\t.controls {\n\t\t  display: flex;\n\t\t  flex-direction: column;\n\t\t}\n      </style>\n    </main>\n    <div class=\"controls\">\n      <button id=\"resetButton\">Regenerate</button>\n      <button id=\"solveButton\">Solve Maze</button>\n    </div>\n  </body>\n</html>",
      "status": "",
      "output": "\n\n  \n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/addons/p5.sound.min.js\"></script>\n    <meta charset=\"utf-8\">\n  \n  \n    <main>\n      <style>\n\t\thtml {\n\t\t  background-color: rgb(50, 50, 50);\n\t\t}\n\n\t\timg {\n\t\t\ttext-align: center;\n\t\t}\n\t\t\n\t\th1 {\n\t\t\tfont-weight: bold;\n\t\t}\t\t\n\n\t\th4 {\n\t\t\tcolor: rgb(0, 255, 0);\n\t\t}\n\n\t\thtml, body {\n\t\t  margin: 10px;\n\t\t  padding: 0;\n\t\t}\n\n\t\tcanvas {\n\t\t  display: flex;\n\t\t}\n\n\t\tmain {\n\t\t  display: flex;\n\t\t  justify-content: center\n\t\t}\n\t\tbody {\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t}\n\n\t\tbutton {\n\t\t\tmargin: 10px auto 0px auto;\n\t\t\tpadding: 10px;\n\t\t\tmax-height: 50px;\n\t\t  max-width: 200px;\n\t\t\tborder: 5px solid rgb(50, 50, 50);\n\t\t\tfont-size: large;\n\t\t\tfont-weight: bold;\n\t\t\tborder-radius: 15px;\n\t\t\tcursor: pointer;\n\t\t\tbackground-color: rgb(220, 220, 220);\n\t\t}\n\n\t\tbutton:hover {\n\t\t\ttransform: scale(1.1);\n\t\t\tbackground-color: rgba(100, 255, 100, 50)\n\t\t}\n\n\t\t.controls {\n\t\t  display: flex;\n\t\t  flex-direction: column;\n\t\t}\n      </style>\n    <canvas id=\"defaultCanvas0\" class=\"p5Canvas\" style=\"width: 400px; height: 400px;\" width=\"800\" height=\"800\"></canvas></main>\n    <div class=\"controls\">\n      <button id=\"resetButton\">Regenerate</button>\n      <button id=\"solveButton\">Solve Maze</button>\n    </div>\n  \n",
      "type": "html"
    },
    {
      "code": "// Importing p5.js\nscrib.loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js\")\n/*\n  Maze Generator and Solver using Depth First Search with Backtracking.\n  Libraries Used:\n  --> Graphics library:\n  https://p5js.org/\n  Resources Used:\n  --> Maze Generation and Maze Solving:\n  https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking\n  https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_implementation\n  https://en.wikipedia.org/wiki/Maze-solving_algorithm\n*/\n\n// Global constants\nconst WIDTH = 400, HEIGHT = WIDTH, WALL_THICKNESS = 3\nconst rows=10, cols=rows, w=WIDTH/cols, h=HEIGHT/rows\nlet grid = [], stack = [], current, destination\nlet currentFromStack = false, mazeGenerated = false, mazeSolving = false\nlet resetButton, solveButton\n\n// The setup function is a p5 function, which is for preloading/initializing stuff\nfunction setup() {\n  createCanvas(WIDTH, HEIGHT)\n  // Initializing the Grid (2D array)\n  for (let i = 0; i<rows; i++) {\n    grid.push([])\n    for (let j = 0; j<cols; j++) {\n      grid[i].push(new Node(i, j))\n    }\n  }\n  resetButton = document.getElementById(\"resetButton\")\n  solveButton = document.getElementById(\"solveButton\")\n  current = grid[0][0]\n  frameRate(20)\n}\n\n// The draw function is a p5 function, which is for redrawing/animating the visuals\n// every frame\nfunction draw() {\n  background(220)\n\n  resetButton.addEventListener(\"click\", regenerate)\n  solveButton.addEventListener(\"click\", solve)\n\n  // Drawing the maze Cells\n  for (let i = 0; i<rows; i++) {\n    for (let j = 0; j<cols; j++) {\n      grid[i][j].drawNode()\n    }\n  }\n  drawPath()\n\n  if (mazeSolving && mazeGenerated) {\n    solveMaze()\n  } else if (!mazeSolving && !mazeGenerated) {\n    generateMaze()\n  }\n\n}\n\n// Draws the blue path which the mazeSolver follows to find the path\nfunction drawPath() {\n  noFill()\n  stroke(0, 0, 255)\n  strokeWeight(5)\n  beginShape()\n  for (let i = 0; i<stack.length; i++) {\n    vertex(stack[i].col * w + (w/2), stack[i].row * h + (h/2))\n  }\n  endShape()\n}\n\n// Maze generation algorithm (DFS with Backtracking)\nfunction generateMaze() {\n  if (!currentFromStack) {\n  // Pusing a node which is not visited yet to the queue\n    stack.push(current)\n    current.visited = true\n  }\n  if (hasUnvisitedNeighbours(current)) {\n  // Selects a random neighbour from around the current cell which has not been visited\n  // and breaks the wall between the current cell and the neighbour\n    let neighbour = null\n    const neighbours = getNeighbours(current)\n    while (neighbour == null || neighbour?.visited == true) {\n      neighbour = random(neighbours)\n    }\n    breakWalls(current, neighbour)\n    current = neighbour\n    currentFromStack = false\n  } else {\n    // If no neighbours which have already not been visited exist the we make the current\n    // the last cell from the queue\n    if (stack.length != 0) {\n      current = stack.pop()\n      currentFromStack = true\n    }\n  }\n\n  if (stack.length == 0 && current == grid[0][0]) {\n    mazeGenerated = true\n  }\n}\n\n// Generates a new maze\nfunction regenerate() {\n  if (mazeGenerated && !mazeSolving) {\n    grid = []\n    for (let i = 0; i<rows; i++) {\n      grid.push([])\n      for (let j = 0; j<cols; j++) {\n        grid[i].push(new Node(i, j))\n      }\n    }\n    current = grid[0][0]\n    stack = []\n    currentFromStack = false\n    setTimeout(() => {mazeGenerated = false}, 1000)\n  }\n}\n\n// Maze solving algorithm (DFS with Backtracking)\nfunction solveMaze() {\n  if (!currentFromStack) {\n  // Pusing a node which is not visited yet to the queue\n    stack.push(current)\n    current.visited = true\n  }\n  // Check if goal reached, resets grid and breaks out of loop if goal reached\n  if (current == destination) {\n    mazeSolving = false\n    for (let i = 0; i<rows; i++) {\n      for (let j = 0; j<cols; j++) {\n        grid[i][j].visited = false\n      }\n    }\n  } else {\n    if (hasUnvisitedNeighbours(current)) {\n    // Selects a random neighbour from around the current cell which doesnt have a wall between\n    // each other and makes the neighbour the current cell\n      const neighbours = getNeighbours(current)\n      let index = floor(random(4))\n      let neighbour = neighbours[index]\n      while (current.walls[index] || neighbour?.visited == true) {\n        index = floor(random(4))\n        neighbour = neighbours[index]\n      }\n      current = neighbour\n      currentFromStack = false\n    } else {\n      if (stack.length != 0) {\n        // If no neighbours which have already not been visited exist the we make the current\n        // the last cell from the queue\n        current = stack.pop()\n        currentFromStack = true\n      }\n    }\n  }\n}\n\n// Function to trigger the maze solver\nfunction solve() {\n  if (mazeGenerated) {\n    current = grid[0][0]\n    destination = grid[rows-1][cols-1]\n    for (let i = 0; i<rows; i++) {\n      for (let j = 0; j<rows; j++) {\n        grid[i][j].visited = false\n      }\n    }\n    stack = []\n    currentFromStack = false\n    mazeSolving = true\n  }\n}\n\n// Helper function to get the neigbours around a cell which dont have walls between them\nfunction availableNeighnours(node) {\n  let neighbours = getNeighbours(node)\n  for (let i = 0; i<4; i++) {\n    if (!node.walls[i] && neighbours[i]?.visited == false) {\n      return true\n    }\n  }\n  return false\n}\n\nclass Node {\n  constructor(row, col) {\n    this.row = row\n    this.col = col\n    this.x = col*w\n    this.y = row*h\n    this.visited = false\n    this.walls = [true, true, true, true]\n  }\n\n  // Purely graphics using p5 functions for drawing a cell of the maze\n  drawNode() {\n    stroke(0)\n    strokeWeight(WALL_THICKNESS)\n    if (this.walls[0]) {\n      line(this.x, this.y, this.x+w, this.y)\n    }\n    if (this.walls[1]) {\n      line(this.x+w, this.y, this.x+w, this.y+h)\n    }\n    if (this.walls[2]) {\n      line(this.x, this.y+h, this.x+w, this.y+h)\n    }\n    if (this.walls[3]) {\n      line(this.x, this.y, this.x, this.y+h)\n    }\n    if (this.row == current.row && this.col == current.col) {\n      noStroke()\n      fill(100, 100, 255, 100)\n      rect(this.x, this.y, w, h)\n    } else if (this.visited) {\n      noStroke()\n      !mazeSolving ? fill(100, 255, 100, 100) : fill(255, 100, 100, 100)\n      rect(this.x, this.y, w, h)\n    }\n  }\n}\n\n// Helper function to get the neighbours around a cell which have not already been visited\nfunction hasUnvisitedNeighbours(node) {\n  const neighbours = getNeighbours(node)\n  for (let i = 0; i<neighbours.length; i++) {\n    if (neighbours[i] != null && neighbours[i]?.visited == false) {\n      return true\n    }\n  }\n  return false\n}\n\n// Helper functions to get all neighbours of a cell\nfunction getNeighbours(node) {\n  const neighbours = [null, null, null, null]\n  if (node.row > 0) {\n    neighbours[0] = grid[node.row-1][node.col]\n  }\n  if (node.col < (cols - 1)) {\n    neighbours[1] = grid[node.row][node.col+1]\n  }\n  if (node.row < (rows-1)) {\n    neighbours[2] = grid[node.row+1][node.col]\n  }\n  if (node.col > 0) {\n    neighbours[3] = grid[node.row][node.col-1]\n  }\n  return neighbours\n}\n\n// Breaks walls between two cells\nfunction breakWalls(node, neighbour) {\n  let x = (node.col - neighbour.col)\n  let y = (node.row - neighbour.row)\n  if (x == 1) {\n    node.walls[3] = false\n    neighbour.walls[1] = false\n  } else if (x == -1) {\n    node.walls[1] = false\n    neighbour.walls[3] = false\n  }\n  if (y == 1) {\n    node.walls[0] = false\n    neighbour.walls[2] = false\n  } else if (y == -1) {\n    node.walls[2] = false\n    neighbour.walls[0] = false\n  }\n}\n",
      "status": "[1]<br><span style=\"font-size:8px\">556ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}